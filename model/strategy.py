import random
import copy


class StrategyAI:
    """
       This class represents the Strategy used by the Computer(the AI) to play the Game
    (using the minmax algorithm for finding the best move)
    """

    def minimax(self, board, depth, alpha, beta, maximizing_player, computer, human):
        """
            This function tries to find the best move that the maximizing player (the Computer) can make
        by anticipating a few moves ahead in the game, assuming that both the opponent (the Human) and the Computer
        play in an optimal manner.
        :param board: the board on which the minimax algorithm tries to find the best possible move
        :param depth: the depth of the tree for the minimax algorithm -> the number of moves the AI tries to foresee
        :param alpha: the best score that the maximizing player (the Computer) can guarantee at a certain level
        :param beta: the best score that the minimizing player (the Human) can guarantee at a certain level
        :param maximizing_player: True - we generate a move for the computer
                                  False - we generate a move for the human
        :param computer: the score the Computer plays with
        :return: column - the column on which a piece is about to be dropped to get the score
                 score - heuristic score of a player at a certain point after making certain moves
        """
        valid_moves = board.get_valid_moves()

        # if the computer has one after one move then he must definitely make that move
        if depth == 3 and board.game_won() == computer:
            return (None, 3000000000000000000000)

        # if the computer can win in two moves then the score has to be high but lower than the previous case
        if depth == 1 and board.game_won() == computer:
            return (None, 30000000000)

        is_terminal = self.is_terminal_node(board)
        if depth == 0 or is_terminal:
            if is_terminal:
                # the game gets won by the human in the future moves
                if board.game_won() == human:
                    return (None, float("-inf"))
                # the game stops because there are no more possible moves on the board (it is full)
                else:
                    return (None, 0)
            else:
                #  We have reached the full depth of the tree -> we return the heuristic score of the leaf nodes
                # by calculating the score of the participant at that point in the game considering his pieces on the board
                return (None, board.score_position(computer))

        # ALPHA BETA PRUNING FOR OPTIMIZATION

        # the maximizing computer = Computer
        if maximizing_player:
            score = float('-inf')
            column = random.choice(valid_moves)
            for col in valid_moves:
                ai_board = copy.deepcopy(board)
                ai_board.move_on_board(col, computer)
                new_score = self.minimax(ai_board, depth - 1, alpha, beta, False, computer, human)[1]
                if new_score > score:
                    score = new_score
                    column = col
                alpha = max(alpha, score)
                if alpha >= beta:
                    break

            return column, score
        # the minimizing computer = Human
        else:
            score = float('inf')
            column = random.choice(valid_moves)
            for col in valid_moves:
                ai_board = copy.deepcopy(board)
                ai_board.move_on_board(col, computer - 1)
                new_score = self.minimax(ai_board, depth - 1, alpha, beta, True, computer, human)[1]
                if new_score < score:
                    score = new_score
                    column = col
                beta = min(beta, score)
                if alpha >= beta:
                    break

            return column, score

    def is_terminal_node(self, board):
        """
            This function checks if we have reached a terminal node in the tree generated by the minimax algorithm.
        A certain node is a terminal node if one of the players has won or if there are no more possible moves to be made.

        :param board: the board of the current game anticipated by AI
        :return: True - it is a terminal node
                 False - otherwise
        """
        return board.winning_move(1) or board.winning_move(2) or len(board.get_valid_moves()) == 0
