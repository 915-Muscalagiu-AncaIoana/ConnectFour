import random
import copy


class StrategyAI:
    """
       This class represents the Strategy used by the Computer(the AI) to play the Game
    (using the minmax algorithm for finding the best move)
    """

    def minimax(self, board, depth, alpha, beta, maximizing_player, player):
        """
            This function tries to find the best move that the maximizing player (the Computer) can make
        by anticipating a few moves ahead in the game, assuming that both the opponent (the Human) and the Computer
        play in an optimal manner.
        :param board: the board on which the minimax algorithm tries to find the best possible move
        :param depth: the depth of the tree for the minimax algorithm -> the number of moves the AI tries to foresee
        :param alpha: the best value that the maximizing player (the Computer) can guarantee at a certain level
        :param beta: the best value that the minimizing player (the Human) can guarantee at a certain level
        :param maximizing_player: True - we generate a move for the computer
                                  False - we generate a move for the human
        :param player: the value the Computer plays with
        :return: column - the column on which a piece is about to be dropped to get the score
                 score - heuristic score of a player at a certain point after making certain moves
        """
        valid_moves = board.get_valid_moves()
        is_terminal = self.is_terminal_node(board)
        if depth == 0 or is_terminal:
            if is_terminal:
                # the game gets won by the computer in the future moves
                if board.game_won() == player:
                    return (None, 10000000)
                # the game gets won by the human in the future moves
                elif board.game_won() == player - 1:
                    return (None, -10000000)
                # the game stops because there are no more possible moves on the board (it is full)
                else:
                    return (None, 0)
            else:
                #  We have reached the full depth of the tree -> we return the heuristic value of the leaf nodes
                # by calculating the score of the participant at that point in the game considering his pieces on the board
                return (None, board.score_position(player))

        # if the computer has one after one move then he must definitely make that move
        if depth == 2 and board.game_won() == player:
            return (None, float("inf"))

        if depth == 1 and board.game_won() == player:
            return (None,100000000)

        # ALPHA BETA PRUNING FOR OPTIMIZATION

        # the maximizing player = Computer
        if maximizing_player:
            value = float('-inf')
            column = random.choice(valid_moves)
            for col in valid_moves:
                ai_board = copy.deepcopy(board)
                ai_board.move_on_board(col, player)
                new_score = self.minimax(ai_board, depth - 1, alpha, beta, False, player)[1]
                if new_score > value:
                    value = new_score
                    column = col
                alpha = max(alpha, value)
                if alpha >= beta:
                    break

            return column, value
        # the minimizing player = Human
        else:
            value = float('inf')
            column = random.choice(valid_moves)
            for col in valid_moves:
                ai_board = copy.deepcopy(board)
                ai_board.move_on_board(col, player - 1)
                new_score = self.minimax(ai_board, depth - 1, alpha, beta, True, player)[1]
                if new_score < value:
                    value = new_score
                    column = col
                beta = min(beta, value)
                if alpha >= beta:
                    break

            return column, value

    def is_terminal_node(self, board):
        """
            This function checks if we have reached a terminal node in the tree generated by the minimax algorithm.
        A certain node is a terminal node if one of the players has won or if there are no more possible moves to be made.

        :param board: the board of the current game anticipated by AI
        :return: True - it is a terminal node
                 False - otherwise
        """
        return board.winning_move(1) or board.winning_move(2) or len(board.get_valid_moves()) == 0

    # def minimax_alpha_beta_algorithm(self, board, depth, player):
    #     valid_moves = board.get_valid_moves_for_ai()
    #     #shuffle(valid_moves)
    #     best_move = valid_moves[0]
    #     best_score = float("-inf")
    #
    #     alpha = float("-inf")
    #     beta = float("inf")
    #
    #     if player == 2:
    #         opponent = 1
    #     else:
    #         opponent = 2
    #
    #     for move in valid_moves:
    #         ai_board = copy.deepcopy(board)
    #         ai_board.move_on_board(move, player)
    #         board_score = self.minimize_beta(ai_board, depth - 1, alpha, beta, player, opponent)
    #         if board_score > best_score:
    #             best_score = board_score
    #             best_move = move
    #
    #     return best_move
    #
    # def minimize_beta(self, board, depth, a, b, player, opponent):
    #     valid_moves = []
    #     for column in range(board.width):
    #         position = board.get_available_move_on_column(column)
    #         if position != -1:
    #             new_board = copy.deepcopy(board)
    #             new_board.apply_move_on_board(position.x, position.y, opponent)
    #             valid_moves.append(column)
    #
    #     if depth == 0 or len(valid_moves) == 0 or board.game_won() is not None:
    #         return board.evaluate_state_of_board(player)
    #
    #     valid_moves = board.get_valid_moves_for_ai()
    #     beta = b
    #
    #     for move in valid_moves:
    #         board_score = float("inf")
    #         if a < beta:
    #             ai_board = copy.deepcopy(board)
    #             ai_board.move_on_board(move, player)
    #             board_score = self.maximize_alpha(ai_board, depth - 1, a, beta, player, opponent)
    #
    #         if board_score < beta:
    #             beta = board_score
    #     return beta
    #
    # def maximize_alpha(self, board, depth, a, b, player, opponent):
    #     valid_moves = []
    #     for column in range(board.width):
    #         position = board.get_available_move_on_column(column)
    #         if position != -1:
    #             new_board = copy.deepcopy(board)
    #             new_board.apply_move_on_board(position.x, position.y, player)
    #             valid_moves.append(column)
    #
    #     if depth == 0 or len(valid_moves) == 0 or board.game_won() is not None:
    #         return board.evaluate_state_of_board(player)
    #
    #     alpha = a
    #
    #     for move in valid_moves:
    #         board_score = float("-inf")
    #         if alpha < a:
    #             ai_board = copy.deepcopy(board)
    #             ai_board.move_on_board(move, opponent)
    #             board_score = self.minimize_beta(ai_board, depth - 1, alpha, b, player, opponent)
    #
    #         if board_score > alpha:
    #             alpha = board_score
    #     return alpha
